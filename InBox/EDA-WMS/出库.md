+ 出库流程:
     + 库存确认:可以提前生成Label,不可以提前生成Label(WOL=withoutLabel)
     + shipmentScheduler将订单变成可下架状态
     + 打包确认,
          + 输入:一般是根据订单号获取产品信息,通过扫描产品BarCode复核产品数量,可以批量复核.
          + 输出:对于生成的包裹产生对应的中性标签(过渡标签).
     + 扫描出单,
          + 输入:一般是扫描中性标签或者装箱单号(标签)
          + 输出:对每一个包裹生成对应的Label
     + 出库确认:
          + 输入:一般都是扫描包裹上的TrackingNum,也可以通过订单号确认出库订单下面的所有包裹.
          + 输出:按物流渠道统计出库订单的数量.


+ 产品部解释:
     + 扫描出单设置功能:对于含一票一件订单的下架单,如果激活了扫描出单,将会在扫描单个产品barcode产生下架单内所有的订单数量的Label.


+ 推荐包材实现:
     + 根据订单中的sku和qty组成模型的list,生成hashcode,找到历史订单表(也叫推荐订单表),
     + 根据推荐订单表找到推荐的包裹信息,里面含有包材信息和包裹里面的产品和数量映射.
     + 将包材,对应产品,对应数量填充到订单的虚拟包裹中,并根据包材信息生成Label,放入订单的虚拟包裹中的labelPath.

+ 问题:
     + 出库单号如果就是装箱单号:扫描装箱单号和扫描订单有什么区别?

+ 熟悉v4如何建立的模型
+ 熟悉Handler和Provider的被使用,熟悉工作流的应用,最终将工作流怎么样整合的Provider和Handler.
+ 营造开发氛围的看法:
     + 形成通用语言,可以借助黑板报形式完善通用语言,另一方面是要提供开发人员的参与积极性.


+ java.io.file表示文件和文件夹
+ 只有在export里的属性才能在templete里面使用
+ npm cache clear      npm install     npm start.
+ ts文件对应DB层,提供数据.Component+Service对应Domain,整个Module对应微服务层.
+ 应用层与服务层的区别在于应用层拥抱并适应变化,服务层保持稳定.
+ Cassandra的查询:主键不能绕过,能in,小于,大于.Index键能绕过,能=.


+ 先移动代码到Provider
+ 查看输入是什么,对接输入,查看需要的输出是什么,对接输出.
     + changedTime+batchNumber+product+boxNo+库位组成联合主键


+ 出库异常:
     + 增加修改地址和修改物流渠道的接口
     + 取消出库单:什么时候可以取消,取消只是简单改变状态?释放库存这些要不要处理?
     + 手工录入的只是简单的更新错误信息,非异常和异常已处理有什么区别?处理的异常有哪些,(方便处理之后应该回退到上一个状态)
+ 库位更正:
     + 已有下架单明细的实际库位修改接口,
+ 调整波次调用算法,在执行算法之后直接修改BizInventory返回,->修改成只返回已修改的BizInventory


